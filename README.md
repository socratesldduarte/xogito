<h1 align="center">A simple User API built in PHP</h1>

## Problem Description

Create an API that runs on PHP 7+, uses PostgreSQL for persistence and supports JSON request payloads. The application should have user accounts that can log in to the system using the Multi-factor authentication (MFA) authentication method. Each account can be either an Administrator or a User.

## Creating tables

My PostgreSQL database has the pgcrypto module installed. So, run the SQL script below in your database, to create the 
users and tokens table.

The users table has a mfa_secret & mfa_validated_at fields to record the key to MFA app and to check if the MFA was already verified.

The tokens table records user generated tokens, with "+ 1 hour" expiration date
```
--DROP TABLE tokens;
--DROP TABLE users;
CREATE EXTENSION IF NOT EXISTS pgcrypto; --AS SUPERUSER

CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(100) NOT NULL UNIQUE,
    name VARCHAR(100) NOT NULL,
    password VARCHAR(40) NOT NULL,
    is_active BOOLEAN DEFAULT true NOT NULL,
    is_administrator BOOLEAN DEFAULT false NOT NULL,
    mfa_secret VARCHAR(40) NOT NULL, -- USED TO REGISTER MFA
    mfa_validated_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE IF NOT EXISTS tokens (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    token VARCHAR(40) NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    expires_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP + interval '1 hours' NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users (id)
);

--TO INSERT A NEW USER, YOU CAN RUN SOMETHING LIKE THE FOLLOWING LINE (THE MFA_SECRET IS A KEY GENERATED BY robthree/twofactorauth) 
INSERT INTO users (email, name, password, mfa_secret) VALUES ('socrates@swge.com.br', 'SÃ³crates Duarte', crypt('yourpassword', gen_salt('md5')), 'FWDUVH4TBUD3KPCT');

--TO AUTHENTICATE AN USER, YOU CAN RUN THE FOLLOWING LINE (RETURN USER IF CREDENTIALS ARE OK, OR A EMPTY SET IF NOT)
SELECT  id, name, email, mfa_secret, mfa_validated_at, is_active, is_administrator, created_at, updated_at FROM users WHERE is_active = true AND email = 'socrates@swge.com.br' AND password = crypt('yourpassword', password);

--THE MULTI FACTOR AUTHENTICATION USES THE robthree/twofactorauth PACKAGE. TO VALIDATE A CODE GENERATED IN MFA APP, THE API USES THE verifyCode METHOD (IN AuthController / checkMFA) 
--TO STORE A NEW TOKEN (GENERATED IN AuthController / checkMFA), YOU CAN RUN THE FOLLOWING LINE
INSERT INTO tokens (user_id, token) VALUES (1, 'a43094120fb41ec48b3a6f3ea7601c2b');
```

## Installing

1 - Clone the repository;

2 - Copy the .env.example to .env in root folder;

3 - Edit the .env file to setup you Postgresql database credentials;

4 - From project folder, execute "php -S 127.0.0.1:8000 -t public" to start the API (in port 8000);

## Explaining the solution

As the objective is to verify the "pure PHP" knowlegde, I used just two packages:

1 - vlucas/phpdotenv - that enables using $_ENV['key'] to get the value of this key from a .env file in root folder; and

2 - robthree/twofactorauth - that manages the Multi Factor Authentication, allowing to register the account in MFA Apps like Google Authenticator and to check the App generated codes.

Of course in a professional project, other packages should be used to improve speed in development and security.

For example, some packages for this project may be an OAuth authentication package, a JWT package, an ORM, a route manager package, and others.

I created a Routes file, where I register all available routes. 

I used two "like middleware features" to protect the routes that needs authentication and administrative privileges.

## Endpoints documentation

The API exposes the following endpoints (with allowed methods between brackets, and the middleware, if any, between braces)
<hr>

#### /register [POST]
The <i>register</i> endpoint allows to create my user record (it's not necessary to be logged in).

The user needs to send a json with the following structure:
```
{
    "email": "address@domain.com",
    "name": "Your name",
    "password": "yourpassword"
}
```

If any of the required fields are not filled in, or the e-mail was already taken, the API return a 422 code.

If everything works well, the API returns a 201 code, and, in the response, the code to be added to the MFA app.
<hr>

#### /login [POST]
The <i>login</i> endpoint allows to authenticate an user - this is the first step to generate a user token.

The user needs to send a json with the following structure:
```
{
    "email": "address@domain.com",
    "password": "yourpassword"
}
```

If any of the required fields are not filled in, the API return a 422 code.

If everything works well, the API returns a 200 code, and if the mfa_code was already validates, a message like ```You need 
to send a POST request the /mfa endpoint, with payload json {"email": "address@domain.com", "mfa_code": "<value from your 
authenticator app (eg. Google Authenticator)>"} to get the token to be send in header of all requests.```, otherwise, the 
message is something like ```You need to add the following code to you authenticator app (eg. Google Authenticator): 
<mfa_secret>. After it, you need to send a POST request the /mfa endpoint, with payload json {"email": "address@domain.com", 
"mfa_code": "<value from your authenticator app>"} to get the token to be send in header of all requests.```
<hr>

#### /mfa [POST]
The <i>mfa</i> endpoint checks the code generated in MFA App - this is the second (and the last) step to generate a user token.

The user needs to send a json with the following structure:
```
{
    "email": "address@domain.com",
    "mfa_code": "<app generated code>"
}
```
If any of the required fields are not filled in, the API return a 422 code.

If everything works well, the API returns a 200 code, and a 32 chars token, that should be used in protected endpoints. 

The token expires in one hour (this is a parameter defined in tokens table creation).

The token needs to be added (in protected endpoints) as a header (Authorization Api Key named "token").
<hr>

#### /user/{id} [GET] {authenticated, administrator}
The <i>/user/{id}</i> endpoint returns a specific user. The {id} is the user_id to be selected in users table.

This endpoint has no payload to send.

The token needs to be added as a header (Authorization Api Key named "token").

If the token was nos sent, or the token is incorrect or expired, the API return a 401 code (Unauthorized).

If the token is a non-admin user token, the API return a 403 code (Forbidden).

If no users has the id sent - or the user is inactive, the API returns a 400 code (resource not found).

If everything works well, the API returns a 200 code, and a json with the user record.
<hr>

#### /users [GET] {authenticated, administrator}
The <i>/users</i> endpoint returns all active users.

This endpoint has no payload to send.

The token needs to be added as a header (Authorization Api Key named "token").

If the token was nos sent, or the token is incorrect or expired, the API return a 401 code (Unauthorized).

If the token is a non-admin user token, the API return a 403 code (Forbidden).

If everything works well, the API returns a 200 code, and a json with the all users from database.
<hr>

#### /user/{id}/updatename [PATCH] {authenticated}
The <i>/user/{id}/updatename</i> endpoint allow to update the name in database. The {id} is the user_id to be updated in users table.

The user needs to send a json with the following structure:
```
{
    "name": "New Name",
}
```

The token needs to be added as a header (Authorization Api Key named "token").

If the token was nos sent, or the token is incorrect or expired, the API return a 401 code (Unauthorized).

If the token is a non-admin user token and the id is another user (not himself), the API return a 403 code (Forbidden).

If everything works well, the API returns a 200 code, and a json with the updated user record.
<hr>

#### /user/{id}/deactivate [PATCH] {authenticated, administrator}
The <i>/user/{id}/deactivate</i> endpoint deactivate an user (set active field = false in database). The {id} is the user_id to be deactivated in users table.

When an user is deactivated, the record he can't login anymore and the record is hidden from /users and /user/{id} endpoints (works like a soft_delete).

This endpoint has no payload to send.

The token needs to be added as a header (Authorization Api Key named "token").

If the token was nos sent, or the token is incorrect or expired, the API return a 401 code (Unauthorized).

If the token is a non-admin user token, the API return a 403 code (Forbidden).

If id is the logged user id, the API return a 403 code (Forbidden), with message "Admin can not deactivate himself.".

If everything works well, the API returns a 200 code, and a json with the updated user record (note the "is_active" field with false value).
<hr>

#### /user/create [POST]
The <i>/user/create</i> endpoint allows to create a new user record.

The user needs to send a json with the following structure:
```
{
    "email": "address@domain.com",
    "name": "Your name",
    "password": "yourpassword"
}
```

If any of the required fields are not filled in, or the e-mail was already taken, the API return a 422 code.

The token needs to be added as a header (Authorization Api Key named "token").

If the token was nos sent, or the token is incorrect or expired, the API return a 401 code (Unauthorized).

If the token is a non-admin user token, the API return a 403 code (Forbidden).

If everything works well, the API returns a 201 code, and, in the response, the code to be added to the MFA app.

## POSTMAN collection

I added a json postman collection in the root of the project.

